name: üîç Inspecci√≥n Pasiva de Gateway

on:
  workflow_dispatch:
    inputs:
      dominio:
        description: 'üåê Dominio a inspeccionar (ej: ejemplo.com)'
        required: true

jobs:
  inspeccion-pasiva:
    runs-on: ubuntu-latest
    name: üåê Inspecci√≥n Pasiva
    steps:

      - name: ‚¨áÔ∏è Checkout del repositorio
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Instalar dependencias necesarias
        run: |
          echo "üîÑ Actualizando e instalando dependencias del sistema..."
          sudo apt-get update -y
          sudo apt-get install -y jq unzip curl whatweb openssl-server # openssl-server para garantir compatibilidade com s_client

          # Instala√ß√£o robusta do httpx
          echo "üì• Descargando e instalando httpx..."
          curl -s https://api.github.com/repos/projectdiscovery/httpx/releases/latest \
            | jq -r '.assets[] | select(.name | test("httpx_.*_linux_amd64.zip")) | .browser_download_url' \
            | xargs curl -L -o httpx.zip
          unzip -o httpx.zip # -o para sobrescrever se j√° existir
          chmod +x httpx
          sudo mv httpx /usr/local/bin/httpx
          rm httpx.zip # Limpa o arquivo ZIP baixado

          # REMOVIDO: Instala√ß√£o do Wappalyzer-Go (conforme decis√£o anterior)

      - name: üåê Ejecutar herramientas pasivas
        run: |
          echo "üîé Dominio a inspeccionar: ${{ inputs.dominio }}"
          
          echo "---"
          echo "üß™ Ejecutando HTTPX..."
          httpx -silent -title -tls-probe -status-code -tech-detect -ip -location -web-server -cdn -json -u ${{ inputs.dominio }} > httpx_output.json
          cat httpx_output.json
          echo "---"

          echo "üß™ Ejecutando WhatWeb..."
          whatweb ${{ inputs.dominio }} > whatweb_output.txt
          cat whatweb_output.txt
          echo "---"

      - name: üìÑ Analizar headers y certificado SSL
        id: analyze_certs # ID para referenciar este passo no resumo do certificado
        run: |
          echo "üîê Obteniendo Headers HTTP/S..."
          curl -s -D - https://${{ inputs.dominio }} -o /dev/null > headers_output.txt
          cat headers_output.txt
          echo "---"
          
          echo "üìú Obteniendo Certificado SSL/TLS..."
          # Usamos timeout para evitar hangs em conex√µes que n√£o respondem
          # Salvamos a sa√≠da diretamente no arquivo para que o pr√≥ximo passo possa l√™-la
          echo | openssl s_client -servername ${{ inputs.dominio }} -connect ${{ inputs.dominio }}:443 -timeout 5 2>/dev/null | openssl x509 -noout -text > cert_output.txt
          # Verifica se o arquivo foi criado e tem conte√∫do antes de tentar cat
          if [ -s "cert_output.txt" ]; then
            cat cert_output.txt
          else
            echo "‚ö†Ô∏è No se pudo obtener el certificado SSL para ${{ inputs.dominio }}."
          fi
          echo "---"

      - name: üìù Resumen detallado del Certificado SSL
        # CORRE√á√ÉO AQUI: Usando hashFiles() para verificar a exist√™ncia do arquivo 'cert_output.txt'
        # A fun√ß√£o hashFiles() retorna uma string vazia se o arquivo n√£o existe ou est√° vazio.
        if: success() && steps.analyze_certs.outcome == 'success' && hashFiles('cert_output.txt') != ''
        run: |
          echo "üìã Resumen del Certificado SSL:"
          CERT_FILE="cert_output.txt"

          # Uma verifica√ß√£o extra dentro do script para garantir
          if [ -s "$CERT_FILE" ]; then 
            ISSUER=$(grep -A 1 "Issuer:" "$CERT_FILE" | tail -n 1 | sed 's/^[[:space:]]*//')
            SUBJECT=$(grep -A 1 "Subject:" "$CERT_FILE" | tail -n 1 | sed 's/^[[:space:]]*//')
            NOT_BEFORE=$(grep "Not Before" "$CERT_FILE" | sed 's/^[[:space:]]*Not Before: //')
            NOT_AFTER=$(grep "Not After" "$CERT_FILE" | sed 's/^[[:space:]]*Not After : //')
            
            SANS=$(grep -A 10 "X509v3 Subject Alternative Name:" "$CERT_FILE" | grep "DNS:" | sed 's/^[[:space:]]*DNS://g' | paste -sd ", " -)
            
            echo "  ‚û°Ô∏è Emisor: **$ISSUER**"
            echo "  ‚û°Ô∏è Sujeto: **$SUBJECT**"
            echo "  ‚û°Ô∏è V√°lido desde: **$NOT_BEFORE**"
            echo "  ‚û°Ô∏è V√°lido hasta: **$NOT_AFTER**"
            if [ -n "$SANS" ]; then
              echo "  ‚û°Ô∏è Nombres Alternativos del Sujeto (SANs): **$SANS**"
            else
              echo "  ‚û°Ô∏è Nombres Alternativos del Sujeto (SANs): *No encontrados o no aplicables*"
            fi
          else
            echo "  ‚ö†Ô∏è No se pudo obtener ou analizar el certificado en detalle."
          fi
          echo "---"

      - name: üß† Consolidar tecnolog√≠as detectadas
        id: tecnologias
        run: |
          echo "üß© Consolidando tecnolog√≠as detectadas por WhatWeb..."
          TECNOLOGIAS=$(cat whatweb_output.txt | grep -oP '\[[^\]]+\]' | sed 's/[\[\]]//g' | sort -u | paste -sd "," -)
          if [ -z "$TECNOLOGIAS" ]; then
            TECNOLOGIAS="No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb."
          fi
          echo "Tecnolog√≠as encontradas: **$TECNOLOGIAS**"
          echo "tecnologias=$TECNOLOGIAS" >> $GITHUB_OUTPUT
          echo "---"

      - name: üêû Buscar CVEs en CIRCL para tecnolog√≠as detectadas
        run: |
          echo "üîç Buscando CVEs relacionados en la base de datos CIRCL..."
          > cve_resultados.txt # Limpa o arquivo de resultados CVE antes de come√ßar

          if [[ "${{ steps.tecnologias.outputs.tecnologias }}" == "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb." ]]; then
            echo "No se encontraron tecnolog√≠as espec√≠ficas para buscar CVEs." >> cve_resultados.txt
          else
            IFS=',' read -ra TECNOS <<< "${{ steps.tecnologias.outputs.tecnologias }}"
            for TEC in "${TECNOS[@]}"; do
              echo "üîé Buscando CVEs para: **$TEC**" >> cve_resultados.txt
              curl -s -L -f "https://cve.circl.lu/api/search/$TEC" | \
                jq -r '.[] | select(.id != null) | "**\(.id)**: \(.summary)"' >> cve_resultados.txt
              echo "---" >> cve_resultados.txt
            done
          fi
          cat cve_resultados.txt
          echo "---"

      - name: ‚úÖ Checklist Final de Inspecci√≥n
        run: |
          echo "üìã **Resumen Final de la Inspecci√≥n:**"
          echo "Dominio: **${{ inputs.dominio }}**"
          echo "---"
          
          # 1. Verificaci√≥n de Tecnolog√≠a Detectada
          if [[ "${{ steps.tecnologias.outputs.tecnologias }}" == "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb." ]]; then
            echo "1. ¬øTecnolog√≠a detectada? ‚ùå (WhatWeb es limitado. Puede requerir an√°lisis manual.)"
          else
            echo "1. ¬øTecnolog√≠a detectada? ‚úÖ (Basado en WhatWeb)"
          fi
          
          # 2. Verificaci√≥n de Gateway de Seguridad
          echo "2. ¬øEs un Gateway de seguridad (WAF, API Gateway, Ingress, Firewall, Balanceador de Carga)?"
          WHATWEB_MATCHES=$(grep -i -E 'cloudflare|akamai|imperva|fastly|aws|api gateway|nginx ingress|waf|f5|palo alto|checkpoint|fortigate|barracuda|citrix|netscaler|azure application gateway|google cloud armor|cloudfront|incapsula|sucuri|mod_security|nginx/waf' whatweb_output.txt)
          HEADERS_MATCHES=$(grep -i -E 'x-forwarded|via|cf-ray|akamai|x-amz|x-cdn|x-gw|x-proxy|server:.*(waf|proxy|gateway|nginx|cloudflare|f5|akamai)|pragma: no-cache|cache-control: no-cache|x-xss-protection|strict-transport-security|content-security-policy|x-frame-options' headers_output.txt)

          if [ -n "$WHATWEB_MATCHES" ] || [ -n "$HEADERS_MATCHES" ]; then
            echo "‚û°Ô∏è **Posible Gateway de seguridad detectado ‚úÖ**"
            echo "   (Detalles de WhatWeb: $WHATWEB_MATCHES)"
            echo "   (Detalles de Headers: $HEADERS_MATCHES)"
          else
            echo "‚ùå No se detect√≥ Gateway de seguridad aparente."
          fi

          # 3. Verificaci√≥n de Paso por Gateway
          echo "3. ¬øPasa por Gateway (x-forwarded, headers espec√≠ficos de proxy/CDN)?"
          if grep -i -E 'x-forwarded|via|x-amz|x-cdn|x-gw|x-proxy' headers_output.txt; then
            echo "‚úÖ Evidencia de paso por Gateway."
          else
            echo "‚ùå No hay evidencia clara de paso por Gateway."
          fi

          # 4. Verificaci√≥n de Certificado V√°lido y Vigente
          echo "4. ¬øCertificado v√°lido y vigente?"
          if grep -q "Not After" cert_output.txt; then
            echo "‚úÖ Certificado analizado."
            # Exemplo: Verificar validade (simplificado, apenas para demonstra√ß√£o)
            # Para uma verifica√ß√£o robusta de expira√ß√£o, seria necess√°rio parsear a data.
            # if echo "$NOT_AFTER" | grep -q "$(date -d '+30 days' '+%b %d %H:%M:%S %Y %Z')"; then
            #   echo "   ‚ö†Ô∏è El certificado podr√≠a expirar pronto (en menos de 30 d√≠as)."
            # fi
          else
            echo "‚ö†Ô∏è No se obtuvo certificado SSL o hubo un error al analizarlo."
          fi

          # 5. Verificaci√≥n de CVEs Encontrados
          echo "5. ¬øCVEs encontrados?"
          if grep -q "CVE-" cve_resultados.txt && [[ "${{ steps.tecnologias.outputs.tecnologias }}" != "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb." ]]; then
            echo "‚ö†Ô∏è **¬°Hay CVEs asociados a las tecnolog√≠as detectadas!** Se recomienda revisi√≥n."
          else
            echo "‚úÖ No se encontraron CVEs relevantes o no se detectaron tecnolog√≠as para buscar."
          fi
          echo "---"
