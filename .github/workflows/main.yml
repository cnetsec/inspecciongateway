name: Inspeccion Gateway

on:
  workflow_dispatch:
    inputs:
      dominio:
        description: 'üåê Dominio o IP a analizar (ej: juice-shop.herokuapp.com)'
        required: true
        type: string
      gemini:
        description: '¬øDesea generar un informe con la IA de Gemini?'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  scan:
    name: An√°lisis de Seguridad y Informe con IA
    runs-on: ubuntu-latest

    steps:
      - name: üîÑ Checkout del c√≥digo
        uses: actions/checkout@v4

      - name: üõ†Ô∏è Instalar herramientas necesarias
        run: |
          set -e
          set -o pipefail

          echo "üîÑ Actualizando e instalando dependencias del sistema..."
          sudo apt-get update -y || echo "‚ö†Ô∏è Advertencia: No se pudo actualizar la lista de paquetes."
          sudo apt-get install -y jq unzip curl whatweb wafw00f nmap || { echo "‚ùå Error cr√≠tico: No se pudieron instalar las dependencias principales."; exit 1; }
          
          # Instala√ß√£o robusta do httpx com retry
          echo "üì• Descargando e instalando httpx..."
          MAX_RETRIES=5
          RETRY_DELAY=5
          DOWNLOAD_URL=""
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Intento $i de $MAX_RETRIES para descargar httpx..."
            # Tenta obter a URL de download. Adicionado '|| echo "{}"' para garantir que jq receba um JSON v√°lido (mesmo que vazio) em caso de falha do curl.
            TEMP_JSON_RESPONSE=$(curl -s https://api.github.com/repos/projectdiscovery/httpx/releases/latest || echo "{}")
            DOWNLOAD_URL=$(echo "$TEMP_JSON_RESPONSE" | jq -r '.assets[] | select(.name | test("httpx_.*_linux_amd64.zip")) | .browser_download_url' 2>/dev/null || echo "") # Garante que DOWNLOAD_URL seja vazia se jq falhar
            
            if [ -n "$DOWNLOAD_URL" ]; then # Verifica se a URL foi encontrada e n√£o est√° vazia
              echo "URL de descarga de httpx encontrada: $DOWNLOAD_URL"
              # Tenta baixar o arquivo. Se o download falhar, o loop continua.
              if curl -L -o httpx.zip "$DOWNLOAD_URL"; then
                break # Sai do loop se o download for bem-sucedido
              else
                echo "‚ö†Ô∏è Advertencia: Fall√≥ la descarga de httpx.zip en el intento $i."
              fi
            else
              echo "‚ö†Ô∏è Advertencia: No se encontr√≥ la URL de descarga de httpx en el intento $i o la respuesta de la API fue inv√°lida."
            fi
            sleep $RETRY_DELAY
          done

          if [ ! -f httpx.zip ]; then
            echo "‚ùå Error cr√≠tico: No se pudo descargar httpx.zip despu√©s de $MAX_RETRIES intentos."
            exit 1
          fi

          unzip -o httpx.zip || { echo "‚ùå Error: No se pudo descomprimir httpx.zip."; exit 1; }
          chmod +x httpx || { echo "‚ùå Error: No se pudo dar permisos de ejecuci√≥n a httpx."; exit 1; }
          sudo mv httpx /usr/local/bin/httpx || { echo "‚ùå Error: No se pudo mover httpx al PATH."; exit 1; }
          rm httpx.zip

          touch gateinspector_raw_logs.txt || true 

      - name: üåê Ejecutar HTTPX
        run: |
          set -o pipefail
          echo "üß™ Ejecutando HTTPX en ${{ inputs.dominio }}..."
          httpx -silent -title -tls-probe -status-code -tech-detect -ip -location -web-server -cdn -json -u ${{ inputs.dominio }} | tee httpx_output.json >> gateinspector_raw_logs.txt || echo "Error al ejecutar HTTPX." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üåê Ejecutar WhatWeb
        run: |
          set -o pipefail
          echo "üß™ Ejecutando WhatWeb en ${{ inputs.dominio }}..."
          whatweb -v ${{ inputs.dominio }} | tee whatweb_output.txt >> gateinspector_raw_logs.txt || echo "Error o objetivo inaccesible para WhatWeb." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üõ°Ô∏è Detectar Firewall de Aplicaci√≥n (Wafw00f)
        run: |
          set -o pipefail
          echo "üõ°Ô∏è Ejecutando Wafw00f en ${{ inputs.dominio }}..."
          wafw00f ${{ inputs.dominio }} | tee wafw00f_output.txt >> gateinspector_raw_logs.txt || echo "Ning√∫n WAF detectado o error con Wafw00f." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üì° Escaneo de Puertos (Nmap)
        run: |
          set -o pipefail
          echo "üì° Ejecutando Nmap (80, 443) en ${{ inputs.dominio }}..."
          nmap -Pn -p 80,443 ${{ inputs.dominio }} | tee nmap_output.txt >> gateinspector_raw_logs.txt || echo "Error en el escaneo de puertos con Nmap." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üìÑ Analizar Headers y Certificado SSL
        id: analyze_certs 
        run: |
          echo "üîê Obteniendo Headers HTTP/S..."
          curl -s -D - https://${{ inputs.dominio }} -o /dev/null | tee headers_output.txt >> gateinspector_raw_logs.txt || echo "Error al obtener headers HTTP/S." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt
          
          echo "üìú Obteniendo Certificado SSL/TLS..."
          touch cert_output.txt
          echo | openssl s_client -servername ${{ inputs.dominio }} -connect ${{ inputs.dominio }}:443 -timeout 5 2>/dev/null | openssl x509 -noout -text > cert_output.txt || echo "Error al ejecutar OpenSSL para el certificado." >> gateinspector_raw_logs.txt
          
          if [ ! -s "cert_output.txt" ]; then 
            echo "‚ö†Ô∏è No se pudo obtener el certificado SSL para ${{ inputs.dominio }} o el archivo est√° vac√≠o." >> gateinspector_raw_logs.txt
          fi
          echo "---" >> gateinspector_raw_logs.txt

      - name: üìù Resumen detallado del Certificado SSL
        id: cert_summary
        if: success() && steps.analyze_certs.outcome == 'success' && hashFiles('cert_output.txt') != ''
        run: |
          echo "üìã Resumen del Certificado SSL:" >> gateinspector_raw_logs.txt
          CERT_FILE="cert_output.txt"
          CERT_EXPIRATION_STATUS="Desconocido"

          if [ -s "$CERT_FILE" ]; then 
            ISSUER=$(grep -A 1 "Issuer:" "$CERT_FILE" | tail -n 1 | sed 's/^[[:space:]]*//' || echo "N/A")
            SUBJECT=$(grep -A 1 "Subject:" "$CERT_FILE" | tail -n 1 | sed 's/^[[:space:]]*//' || echo "N/A")
            NOT_BEFORE=$(grep "Not Before" "$CERT_FILE" | sed 's/^[[:space:]]*Not Before: //'|| echo "N/A")
            NOT_AFTER=$(grep "Not After" "$CERT_FILE" | sed 's/^[[:space:]]*Not After : //'|| echo "N/A")
            
            SANS=$(grep -A 10 "X509v3 Subject Alternative Name:" "$CERT_FILE" | grep "DNS:" | sed 's/^[[:space:]]*DNS://g' | paste -sd ", " - || echo "No encontrados o no aplicables")
            
            echo "  ‚û°Ô∏è Emisor: $ISSUER" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è Sujeto: $SUBJECT" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è V√°lido desde: $NOT_BEFORE" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è V√°lido hasta: $NOT_AFTER" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è Nombres Alternativos del Sujeto (SANs): $SANS" >> gateinspector_raw_logs.txt

            if [ "$NOT_AFTER" != "N/A" ]; then
              NOT_AFTER_TIMESTAMP=$(date -d "$NOT_AFTER" +%s)
              CURRENT_TIMESTAMP=$(date +%s)
              DAYS_REMAINING=$(( (NOT_AFTER_TIMESTAMP - CURRENT_TIMESTAMP) / (60*60*24) ))

              if [ "$DAYS_REMAINING" -lt 0 ]; then
                CERT_EXPIRATION_STATUS="Expirado"
              elif [ "$DAYS_REMAINING" -le 30 ]; then
                CERT_EXPIRATION_STATUS="Pr√≥ximo a expirar ($DAYS_REMAINING d√≠as restantes)"
              else
                CERT_EXPIRATION_STATUS="V√°lido"
              fi
            fi
            echo "  ‚û°Ô∏è Estado de Expiraci√≥n: $CERT_EXPIRATION_STATUS" >> gateinspector_raw_logs.txt
            echo "cert_expiration_status=$CERT_EXPIRATION_STATUS" >> $GITHUB_OUTPUT
          else
            echo "  ‚ö†Ô∏è No se pudo obtener o analizar el certificado en detalle (archivo vac√≠o o no existente)." >> gateinspector_raw_logs.txt
            echo "cert_expiration_status=No obtenido/Error" >> $GITHUB_OUTPUT
          fi
          echo "---" >> gateinspector_raw_logs.txt

      - name: üß† Consolidar tecnolog√≠as y Datos para Informe
        id: consolidated_data
        run: |
          echo "üß© Consolidando informaci√≥n para el informe y el checklist..." >> gateinspector_raw_logs.txt
          
          # CORRE√á√ÉO AQUI: Limpeza mais robusta dos nomes das tecnologias do WhatWeb
          CLEAN_WHATWEB_OUTPUT=$(sed 's/\x1b\[[0-9;]*m//g' whatweb_output.txt 2>/dev/null)
          TECNOLOGIAS_WHATWEB=$(echo "$CLEAN_WHATWEB_OUTPUT" | \
            grep -oP '\[\s*\K[^\]]+' | \
            sed -E 's/\s*\[[^\]]+\]|\s*\([^\)]+\)//g; s/[0-9\.]+//g; s/\s*,\s*/,/g; s/^\s*|\s*$//g' | \
            tr ' ' ',' | tr -s ',' | sort -u | paste -sd "," - || echo "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb.")
          
          echo "Tecnolog√≠as WhatWeb: $TECNOLOGIAS_WHATWEB" >> gateinspector_raw_logs.txt
          echo "tecnologias=$TECNOLOGIAS_WHATWEB" >> $GITHUB_OUTPUT

          WHATWEB_GW_MATCHES=$(cat whatweb_output.txt 2>/dev/null | grep -i -E 'cloudflare|akamai|imperva|fastly|aws|api gateway|nginx ingress|waf|f5|palo alto|checkpoint|fortigate|barracuda|citrix|netscaler|azure application gateway|google cloud armor|cloudfront|incapsula|sucuri|mod_security|nginx/waf' || true)
          HEADERS_GW_MATCHES=$(cat headers_output.txt 2>/dev/null | grep -i -E 'x-forwarded|via|cf-ray|akamai|x-amz|x-cdn|x-gw|x-proxy|server:.*(waf|proxy|gateway|nginx|cloudflare|f5|akamai)|pragma: no-cache|cache-control: no-cache|x-xss-protection|strict-transport-security|content-security-policy|x-frame-options' || true)
          
          if [ -n "$WHATWEB_GW_MATCHES" ] || [ -n "$HEADERS_GW_MATCHES" ]; then
            echo "Posible Gateway de seguridad detectado: S√≠" >> gateinspector_raw_logs.txt
            echo "   (Detalles de WhatWeb: $WHATWEB_GW_MATCHES)" >> gateinspector_raw_logs.txt
            echo "   (Detalles de Headers: $HEADERS_GW_MATCHES)" >> gateinspector_raw_logs.txt
            echo "gateway_detected=true" >> $GITHUB_OUTPUT
          else
            echo "Posible Gateway de seguridad detectado: No" >> gateinspector_raw_logs.txt
            echo "gateway_detected=false" >> $GITHUB_OUTPUT
          fi

          echo "---" >> gateinspector_raw_logs.txt

      - name: üêû Buscar CVEs en CIRCL para tecnolog√≠as detectadas
        run: |
          echo "üîç Buscando CVEs relacionados en la base de datos CIRCL..."
          > cve_resultados.txt 

          if [[ "${{ steps.consolidated_data.outputs.tecnologias }}" == "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb." ]]; then
            echo "No se encontraron tecnolog√≠as espec√≠ficas para buscar CVEs." >> cve_resultados.txt
          else
            IFS=',' read -ra TECNOS <<< "${{ steps.consolidated_data.outputs.tecnologias }}"
            for TEC in "${TECNOS[@]}"; do
              if [[ ${#TEC} -lt 3 ]]; then # Pula termos muito curtos
                continue
              fi
              echo "üîé Buscando CVEs para: **$TEC**" >> cve_resultados.txt
              curl -s -L -f "https://cve.circl.lu/api/search/$TEC" | \
                jq -r '.[] | select(.id != null) | "**\(.id)**: \(.summary)"' >> cve_resultados.txt || echo "Error al consultar CVEs para $TEC." >> cve_resultados.txt
              echo "---" >> cve_resultados.txt
            done
          fi
          cat cve_resultados.txt
          echo "---"

      - name: ü§ñ Generar Informe con Gemini (Opcional)
        id: generate_gemini_report # Adicionado ID para o passo do Gemini
        if: inputs.gemini == 'true'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -e
          set -o pipefail
          echo "üß† Consolidando resultados y generando informe con Gemini..."

          if [ ! -s gateinspector_raw_logs.txt ]; then
            echo "‚ùå Archivo de log 'gateinspector_raw_logs.txt' no encontrado o vac√≠o. No se puede generar el informe de Gemini."
            echo "gemini_report_status=failed" >> $GITHUB_OUTPUT # Publica status de falha
            exit 1
          fi
          
          LOG_CONTENT=$(sed 's/\x1b\[[0-9;]*m//g' gateinspector_raw_logs.txt)

          PROMPT_TEXT="Eres un experto en ciberseguridad y pentester. Analiza los siguientes logs brutos generados por las herramientas HTTPX, WhatWeb, Wafw00f, Nmap, y curl (para headers y certificados SSL) para el objetivo '${{ inputs.dominio }}'. Crea un informe claro y conciso en formato Markdown.

          El informe debe contener las siguientes secciones:

          1.  **Resumen Ejecutivo:** Un p√°rrafo conciso con las principales conclusiones de la inspecci√≥n pasiva, destacando si se detect√≥ un gateway de seguridad o WAF y la salud general del objetivo.
          2.  **Informaci√≥n General del Objetivo:**
              * **Dominio/IP:** ${{ inputs.dominio }}
              * **Tecnolog√≠as Identificadas (HTTPX, WhatWeb):** Enumera las tecnolog√≠as detectadas, incluyendo versiones si est√°n disponibles.
              * **Servidor Web:** (Si se detecta)
              * **CDN/WAF Detectado (Wafw00f, Headers):** Indica si se detect√≥ un WAF o CDN, y cu√°l.
              * **Puertos Abiertos (Nmap):** Lista los puertos 80 y 443 y su estado.
          3.  **An√°lisis de Certificado SSL/TLS:**
              * **Emisor:**
              * **Sujeto:**
              * **Validez (Desde/Hasta):**
              * **Nombres Alternativos (SANs):**
              * **Estado de Expiraci√≥n:** (V√°lido, pr√≥ximo a expirar, expirado, no obtenido)
          4.  **An√°lisis de Encabezados HTTP/S:**
              * **Headers de Seguridad Clave:** (X-XSS-Protection, Strict-Transport-Security, Content-Security-Policy, X-Frame-Options, X-Content-Type-Options) y su estado (presente/ausente, valor).
              * **Headers de Informaci√≥n (Server, X-Powered-By):** Si se detectan, con sus valores.
              * **Headers de Proxy/CDN (X-Forwarded-For, Via, CF-Ray, etc.):** Indica si se detectan y si sugieren un paso por gateway.
          5.  **Vulnerabilidades Potenciales y Riesgos (Basado en CVEs y Tecnolog√≠as):**
              * Basado en las tecnolog√≠as identificadas, lista posibles vectores de ataque o CVEs conocidas que podr√≠an ser explotadas. S√© espec√≠fico (ej: 'La versi√≥n X de Nginx es vulnerable a Y'). Considera si el WAF/Gateway es vulnerable o si est√° mal configurado.
              * Analiza si la ausencia de headers de seguridad clave representa un riesgo.
          6.  **Recomendaciones y Pr√≥ximos Pasos:** Sugiere los pr√≥ximos 3 a 5 pasos para profundizar la an√°lisis de seguridad y mejorar la postura de seguridad del objetivo.

          Aqu√≠ est√°n los logs brutos completos de todas las herramientas. Anal√≠zalos cuidadosamente para extraer toda la informaci√≥n relevante y generar el informe seg√∫n el formato solicitado.
          "

          (
            echo '{ "contents": [ { "parts": [ { "text": "'
            echo "$PROMPT_TEXT" | sed 's/\\/\\\\/g; s/"/\\"/g'
            echo ""
            cat gateinspector_raw_logs.txt | sed 's/\\/\\\\/g; s/"/\\"/g; s/\x1b\[[0-9;]*m//g'
            echo '" } ] } ] }'
          ) | curl -s -X POST -H "Content-Type: application/json" \
            -d @- \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$GEMINI_API_KEY" > gemini_api_response.json || { echo "‚ùå Error: Fall√≥ la llamada a la API de Gemini."; echo "gemini_report_status=failed" >> $GITHUB_OUTPUT; exit 1; }

          RESPONSE=$(cat gemini_api_response.json)

          if echo "$RESPONSE" | jq -e 'has("error")' > /dev/null; then
            echo "‚ùå La API de Gemini retorn√≥ un error:"
            echo "$RESPONSE" | jq .
            echo "gemini_report_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if ! echo "$RESPONSE" | jq -e '.candidates[0].content.parts[0].text' > /dev/null; then
            echo "‚ùå La API de Gemini no retorn√≥ un an√°lisis v√°lido (puede haber sido bloqueado por seguridad o respuesta inesperada)."
            echo "Respuesta recibida:"
            echo "$RESPONSE" | jq .
            echo "gemini_report_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "--- INFORME GENERADO POR INSPECCION GATEWAY (VIA GEMINI AI) ---"
          echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text' > gemini_report.md
          cat gemini_report.md
          echo "---------------------------------------------------------"
          rm gemini_api_response.json
          echo "gemini_report_status=success" >> $GITHUB_OUTPUT # Publica status de sucesso

      - name: ‚úÖ Conclusi√≥n Final del An√°lisis
        run: |
          echo "---"
          echo "‚ú® **CONCLUSI√ìN FINAL DEL AN√ÅLISIS DE INSPECCI√ìN GATEWAY** ‚ú®"
          echo "---"

          # Verifica se o Gemini foi ativado e se o relat√≥rio foi gerado com sucesso
          if [[ "${{ inputs.gemini }}" == "true" && "${{ steps.generate_gemini_report.outputs.gemini_report_status }}" == "success" && -s "gemini_report.md" ]]; then
            echo "‚úÖ **¬°An√°lisis Completo y Empoderado por Gemini AI!**"
            echo "El informe detallado generado por la inteligencia artificial de Gemini proporciona una visi√≥n profunda y recomendaciones espec√≠ficas."
            echo "Por favor, revise el informe a continuaci√≥n o descargue 'gemini_report.md' de los artefactos del workflow."
            echo ""
            echo "--- INFORME DETALLADO DE GEMINI ---"
            cat gemini_report.md || echo "Error al mostrar el informe de Gemini."
            echo "--- FIN DEL INFORME DETALLADO ---"
          else
            echo "‚û°Ô∏è **An√°lisis Basado en Herramientas Est√°ndar.**"
            echo "El informe de Gemini no fue solicitado o no pudo ser generado. La siguiente es una tabla resumen de los hallazgos."
            echo "Para un an√°lisis m√°s profundo, considere activar la opci√≥n 'Gemini' en la pr√≥xima ejecuci√≥n."
            echo ""
            # Re-executa o checklist final para garantir que esteja vis√≠vel aqui
            # (Este √© um duplicado do passo anterior, mas garante a visibilidade na conclus√£o)
            echo "üìã **Resumen de Hallazgos (Checklist Est√°ndar):**"
            echo "Dominio: **${{ inputs.dominio }}**"
            echo "---"
            
            if [[ "${{ steps.consolidated_data.outputs.tecnologias }}" == "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb." ]]; then
              echo "1. ¬øTecnolog√≠a detectada? ‚ùå (WhatWeb es limitado. Puede requerir an√°lisis manual.)"
            else
              echo "1. ¬øTecnolog√≠a detectada? ‚úÖ (Basado en WhatWeb)"
            fi
            
            echo "2. ¬øEs un Gateway de seguridad (WAF, API Gateway, Ingress, Firewall, Balanceador de Carga)?"
            if [[ "${{ steps.consolidated_data.outputs.gateway_detected }}" == "true" ]]; then
              echo "‚û°Ô∏è **Posible Gateway de seguridad detectado ‚úÖ**"
            else
              echo "‚ùå No se detect√≥ Gateway de seguridad aparente."
            fi

            echo "3. ¬øPasa por Gateway (x-forwarded, headers espec√≠ficos de proxy/CDN)?"
            if cat headers_output.txt 2>/dev/null | grep -i -E 'x-forwarded|via|x-amz|x-cdn|x-gw|x-proxy'; then
              echo "‚úÖ Evidencia de paso por Gateway."
            else
              echo "‚ùå No hay evidencia clara de paso por Gateway."
            fi

            echo "4. ¬øCertificado v√°lido y vigente?"
            echo "Estado: ${{ steps.cert_summary.outputs.cert_expiration_status }}"
            if [[ "${{ steps.cert_summary.outputs.cert_expiration_status }}" == "V√°lido" ]]; then
              echo "‚úÖ Certificado v√°lido."
            elif [[ "${{ steps.cert_summary.outputs.cert_expiration_status }}" == "Pr√≥ximo a expirar"* ]]; then
              echo "‚ö†Ô∏è Certificado pr√≥ximo a expirar."
            elif [[ "${{ steps.cert_summary.outputs.cert_expiration_status }}" == "Expirado" ]]; then
              echo "‚ùå Certificado expirado."
            else
              echo "‚ö†Ô∏è Estado del certificado desconocido o no obtenido."
            fi

            echo "5. ¬øCVEs encontrados?"
            if [ -s "cve_resultados.txt" ] && grep -q "CVE-" cve_resultados.txt; then
              echo "‚ö†Ô∏è **¬°Hay CVEs asociados a las tecnolog√≠as detectadas!** Se recomienda revisi√≥n."
            else
              echo "‚úÖ No se encontraron CVEs relevantes o no se detectaron tecnolog√≠as para buscar."
            fi
            echo "---"
          fi
          echo "--- FIN DEL AN√ÅLISIS ---"

      - name: ‚¨ÜÔ∏è Subir Artefactos de An√°lisis
        uses: actions/upload-artifact@v4
        with:
          name: inspeccion-gateway-results-${{ github.run_id }}
          path: |
            httpx_output.json
            whatweb_output.txt
            wafw00f_output.txt
            nmap_output.txt
            headers_output.txt
            cert_output.txt
            cve_resultados.txt
            gateinspector_raw_logs.txt
            gemini_report.md
          if-no-files-found: ignore
