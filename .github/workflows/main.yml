name: Inspeccion Gateway

on:
  workflow_dispatch:
    inputs:
      dominio:
        description: 'üåê Dominio o IP a analizar (ej: juice-shop.herokuapp.com)'
        required: true
        type: string
      gemini:
        description: '¬øDesea generar un informe con la IA de Gemini?'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  scan:
    name: An√°lisis de Seguridad y Informe con IA
    runs-on: ubuntu-latest

    steps:
      - name: üîÑ Checkout del c√≥digo
        uses: actions/checkout@v4

      - name: üõ†Ô∏è Instalar herramientas necesarias
        run: |
          set -e
          set -o pipefail

          echo "üîÑ Actualizando e instalando dependencias del sistema..."
          sudo apt-get update -y || echo "‚ö†Ô∏è Advertencia: No se pudo actualizar la lista de paquetes."
          sudo apt-get install -y jq unzip curl whatweb wafw00f nmap || { echo "‚ùå Error cr√≠tico: No se pudieron instalar las dependencias principales."; exit 1; }
          
          # Instalaci√≥n robusta de httpx con reintentos
          echo "üì• Descargando e instalando httpx..."
          MAX_RETRIES=5
          RETRY_DELAY=5
          DOWNLOAD_URL=""
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Intento $i de $MAX_RETRIES para descargar httpx..."
            # Intenta obtener la URL de descarga. Se a√±ade '|| echo "{}"' para asegurar que jq reciba un JSON v√°lido (aunque vac√≠o) en caso de fallo de curl.
            TEMP_JSON_RESPONSE=$(curl -s https://api.github.com/repos/projectdiscovery/httpx/releases/latest || echo "{}")
            DOWNLOAD_URL=$(echo "$TEMP_JSON_RESPONSE" | jq -r '.assets[] | select(.name | test("httpx_.*_linux_amd64.zip")) | .browser_download_url' 2>/dev/null || echo "") # Asegura que DOWNLOAD_URL est√© vac√≠a si jq falla
            
            if [ -n "$DOWNLOAD_URL" ]; then # Verifica si la URL fue encontrada y no est√° vac√≠a
              echo "URL de descarga de httpx encontrada: $DOWNLOAD_URL"
              # Intenta descargar el archivo. Si la descarga falla, el bucle contin√∫a.
              if curl -L -o httpx.zip "$DOWNLOAD_URL"; then
                break # Sale del bucle si la descarga es exitosa
              else
                echo "‚ö†Ô∏è Advertencia: Fall√≥ la descarga de httpx.zip en el intento $i."
              fi
            else
              echo "‚ö†Ô∏è Advertencia: No se encontr√≥ la URL de descarga de httpx en el intento $i o la respuesta de la API fue inv√°lida."
            fi
            sleep $RETRY_DELAY
          done

          if [ ! -f httpx.zip ]; then
            echo "‚ùå Error cr√≠tico: No se pudo descargar httpx.zip despu√©s de $MAX_RETRIES intentos."
            exit 1
          fi

          unzip -o httpx.zip || { echo "‚ùå Error: No se pudo descomprimir httpx.zip."; exit 1; }
          chmod +x httpx || { echo "‚ùå Error: No se pudo dar permisos de ejecuci√≥n a httpx."; exit 1; }
          sudo mv httpx /usr/local/bin/httpx || { echo "‚ùå Error: No se pudo mover httpx al PATH."; exit 1; }
          rm httpx.zip

          touch gateinspector_raw_logs.txt || true 

      - name: üåê Ejecutar HTTPX
        run: |
          set -o pipefail
          echo "üß™ Ejecutando HTTPX en ${{ inputs.dominio }}..."
          httpx -silent -title -tls-probe -status-code -tech-detect -ip -location -web-server -cdn -json -u ${{ inputs.dominio }} | tee httpx_output.json >> gateinspector_raw_logs.txt || echo "Error al ejecutar HTTPX." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üåê Ejecutar WhatWeb
        run: |
          set -o pipefail
          echo "üß™ Ejecutando WhatWeb en ${{ inputs.dominio }}..."
          whatweb -v ${{ inputs.dominio }} | tee whatweb_output.txt >> gateinspector_raw_logs.txt || echo "Error o objetivo inaccesible para WhatWeb." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üõ°Ô∏è Detectar Firewall de Aplicaci√≥n (Wafw00f)
        run: |
          set -o pipefail
          echo "üõ°Ô∏è Ejecutando Wafw00f en ${{ inputs.dominio }}..."
          wafw00f ${{ inputs.dominio }} | tee wafw00f_output.txt >> gateinspector_raw_logs.txt || echo "Ning√∫n WAF detectado o error con Wafw00f." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üì° Escaneo de Puertos (Nmap)
        run: |
          set -o pipefail
          echo "üì° Ejecutando Nmap (80, 443) en ${{ inputs.dominio }}..."
          nmap -Pn -p 80,443 ${{ inputs.dominio }} | tee nmap_output.txt >> gateinspector_raw_logs.txt || echo "Error en el escaneo de puertos con Nmap." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt

      - name: üìÑ Analizar Cabeceras y Certificado SSL
        id: analyze_certs 
        run: |
          echo "üîê Obteniendo Cabeceras HTTP/S..."
          curl -s -D - https://${{ inputs.dominio }} -o /dev/null | tee headers_output.txt >> gateinspector_raw_logs.txt || echo "Error al obtener cabeceras HTTP/S." >> gateinspector_raw_logs.txt
          echo "---" >> gateinspector_raw_logs.txt
          
          echo "üìú Obteniendo Certificado SSL/TLS..."
          touch cert_output.txt
          echo | openssl s_client -servername ${{ inputs.dominio }} -connect ${{ inputs.dominio }}:443 -timeout 5 2>/dev/null | openssl x509 -noout -text > cert_output.txt || echo "Error al ejecutar OpenSSL para el certificado." >> gateinspector_raw_logs.txt
          
          if [ ! -s "cert_output.txt" ]; then 
            echo "‚ö†Ô∏è No se pudo obtener el certificado SSL para ${{ inputs.dominio }} o el archivo est√° vac√≠o." >> gateinspector_raw_logs.txt
          fi
          echo "---" >> gateinspector_raw_logs.txt

      - name: üìù Resumen detallado del Certificado SSL
        id: cert_summary
        if: success() && steps.analyze_certs.outcome == 'success' && hashFiles('cert_output.txt') != ''
        run: |
          echo "üìã Resumen del Certificado SSL:" >> gateinspector_raw_logs.txt
          CERT_FILE="cert_output.txt"
          CERT_EXPIRATION_STATUS="Desconocido"

          if [ -s "$CERT_FILE" ]; then 
            ISSUER=$(grep -A 1 "Issuer:" "$CERT_FILE" | tail -n 1 | sed 's/^[[:space:]]*//' || echo "N/A")
            SUBJECT=$(grep -A 1 "Subject:" "$CERT_FILE" | tail -n 1 | sed 's/^[[:space:]]*//' || echo "N/A")
            NOT_BEFORE=$(grep "Not Before" "$CERT_FILE" | sed 's/^[[:space:]]*Not Before: //'|| echo "N/A")
            NOT_AFTER=$(grep "Not After" "$CERT_FILE" | sed 's/^[[:space:]]*Not After : //'|| echo "N/A")
            
            SANS=$(grep -A 10 "X509v3 Subject Alternative Name:" "$CERT_FILE" | grep "DNS:" | sed 's/^[[:space:]]*DNS://g' | paste -sd ", " - || echo "No encontrados o no aplicables")
            
            echo "  ‚û°Ô∏è Emisor: $ISSUER" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è Sujeto: $SUBJECT" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è V√°lido desde: $NOT_BEFORE" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è V√°lido hasta: $NOT_AFTER" >> gateinspector_raw_logs.txt
            echo "  ‚û°Ô∏è Nombres Alternativos del Sujeto (SANs): $SANS" >> gateinspector_raw_logs.txt

            if [ "$NOT_AFTER" != "N/A" ]; then
              NOT_AFTER_TIMESTAMP=$(date -d "$NOT_AFTER" +%s)
              CURRENT_TIMESTAMP=$(date +%s)
              DAYS_REMAINING=$(( (NOT_AFTER_TIMESTAMP - CURRENT_TIMESTAMP) / (60*60*24) ))

              if [ "$DAYS_REMAINING" -lt 0 ]; then
                CERT_EXPIRATION_STATUS="Expirado"
              elif [ "$DAYS_REMAINING" -le 30 ]; then
                CERT_EXPIRATION_STATUS="Pr√≥ximo a expirar ($DAYS_REMAINING d√≠as restantes)"
              else
                CERT_EXPIRATION_STATUS="V√°lido"
              fi
            fi
            echo "  ‚û°Ô∏è Estado de Expiraci√≥n: $CERT_EXPIRATION_STATUS" >> gateinspector_raw_logs.txt
            echo "cert_expiration_status=$CERT_EXPIRATION_STATUS" >> $GITHUB_OUTPUT
          else
            echo "  ‚ö†Ô∏è No se pudo obtener o analizar el certificado en detalle (archivo vac√≠o o no existente)." >> gateinspector_raw_logs.txt
            echo "cert_expiration_status=No obtenido/Error" >> $GITHUB_OUTPUT
          fi
          echo "---" >> gateinspector_raw_logs.txt

      - name: üß† Consolidar tecnolog√≠as y Datos para Informe
        id: consolidated_data
        run: |
          echo "üß© Consolidando informaci√≥n para el informe y el checklist..." >> gateinspector_raw_logs.txt
          
          CLEAN_WHATWEB_OUTPUT=$(sed 's/\x1b\[[0-9;]*m//g' whatweb_output.txt 2>/dev/null)
          TECNOLOGIAS_WHATWEB=$(echo "$CLEAN_WHATWEB_OUTPUT" | \
            grep -oP '\[\s*\K[^\]]+' | \
            sed -E 's/\s*\[[^\]]+\]|\s*\([^\)]+\)//g; s/[0-9\.]+//g; s/\s*,\s*/,/g; s/^\s*|\s*$//g' | \
            tr ' ' ',' | tr -s ',' | sort -u | paste -sd "," - || echo "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb.")
          
          echo "Tecnolog√≠as WhatWeb: $TECNOLOGIAS_WHATWEB" >> gateinspector_raw_logs.txt
          echo "tecnologias=$TECNOLOGIAS_WHATWEB" >> $GITHUB_OUTPUT

          WHATWEB_GW_MATCHES=$(cat whatweb_output.txt 2>/dev/null | grep -i -E 'cloudflare|akamai|imperva|fastly|aws|api gateway|nginx ingress|waf|f5|palo alto|checkpoint|fortigate|barracuda|citrix|netscaler|azure application gateway|google cloud armor|cloudfront|incapsula|sucuri|mod_security|nginx/waf' || true)
          HEADERS_GW_MATCHES=$(cat headers_output.txt 2>/dev/null | grep -i -E 'x-forwarded|via|cf-ray|akamai|x-amz|x-cdn|x-gw|x-proxy|server:.*(waf|proxy|gateway|nginx|cloudflare|f5|akamai)|pragma: no-cache|cache-control: no-cache|x-xss-protection|strict-transport-security|content-security-policy|x-frame-options' || true)
          
          if [ -n "$WHATWEB_GW_MATCHES" ] || [ -n "$HEADERS_GW_MATCHES" ]; then
            echo "Posible Gateway de seguridad detectado: S√≠" >> gateinspector_raw_logs.txt
            echo "   (Detalles de WhatWeb: $WHATWEB_GW_MATCHES)" >> gateinspector_raw_logs.txt
            echo "   (Detalles de Headers: $HEADERS_GW_MATCHES)" >> gateinspector_raw_logs.txt
            echo "gateway_detected=true" >> $GITHUB_OUTPUT
          else
            echo "Posible Gateway de seguridad detectado: No" >> gateinspector_raw_logs.txt
            echo "gateway_detected=false" >> $GITHUB_OUTPUT
          fi

          echo "---" >> gateinspector_raw_logs.txt

      - name: üêû Buscar CVEs en CIRCL para tecnolog√≠as detectadas
        run: |
          echo "üîç Buscando CVEs relacionados en la base de datos CIRCL..."
          > cve_resultados.txt 

          if [[ "${{ steps.consolidated_data.outputs.tecnologias }}" == "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb." ]]; then
            echo "No se encontraron tecnolog√≠as espec√≠ficas para buscar CVEs." >> cve_resultados.txt
          else
            IFS=',' read -ra TECNOS <<< "${{ steps.consolidated_data.outputs.tecnologias }}"
            for TEC in "${TECNOS[@]}"; do
              if [[ ${#TEC} -lt 3 ]]; then
                continue
              fi
              echo "üîé Buscando CVEs para: **$TEC**" >> cve_resultados.txt
              curl -s -L -f "https://cve.circl.lu/api/search/$TEC" | \
                jq -r '.[] | select(.id != null) | "**\(.id)**: \(.summary)"' >> cve_resultados.txt || echo "Error al consultar CVEs para $TEC." >> cve_resultados.txt
              echo "---" >> cve_resultados.txt
            done
          fi
          cat cve_resultados.txt
          echo "---"

      - name: ü§ñ Generar Informe con Gemini (Opcional)
        id: generate_gemini_report
        if: inputs.gemini == 'true'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -e
          set -o pipefail
          echo "üß† Consolidando resultados y generando informe con Gemini..."

          if [ ! -s gateinspector_raw_logs.txt ]; then
            echo "‚ùå Archivo de log 'gateinspector_raw_logs.txt' no encontrado o vac√≠o. No se puede generar el informe de Gemini."
            echo "gemini_report_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          LOG_CONTENT=$(sed 's/\x1b\[[0-9;]*m//g' gateinspector_raw_logs.txt)

          # --- PROMPT PARA EL GEMINI ---
          PROMPT_TEXT="Eres un experto en ciberseguridad y pentester. Analiza los siguientes logs brutos generados por las herramientas HTTPX, WhatWeb, Wafw00f, Nmap, y curl (para cabeceras y certificados SSL) para el objetivo '${{ inputs.dominio }}'. Crea un informe claro y conciso en formato Markdown.

          El informe debe contener las siguientes secciones:

          ## 0. Resumen R√°pido (Checklist):
          Basado en tu an√°lisis de los logs brutos, genera un checklist conciso con el formato 'Emoji Descripci√≥n del punto'. Utiliza ‚úÖ para positivo/seguro, ‚ùå para negativo/inseguro, ‚ö†Ô∏è para atenci√≥n/aviso (e.g., CVEs, certificado expirando), y ‚ùì para desconocido/error.
          Aseg√∫rate de que las descripciones de los puntos sean **id√©nticas** a las siguientes y que los emojis est√©n a la izquierda:
          - ‚úÖ El objetivo es un Gateway de Seguridad (WAF, Ingress, CDN, etc.)
          - ‚úÖ El tr√°fico pasa por un Gateway/Proxy
          - ‚úÖ Tecnolog√≠a detectada
          - ‚úÖ Certificado SSL/TLS v√°lido y vigente
          - ‚ö†Ô∏è CVEs encontrados para tecnolog√≠as detectadas (revisar)

          ## 1. Resumen Ejecutivo:
          Un p√°rrafo conciso con las principales conclusiones de la inspecci√≥n pasiva, destacando si se detect√≥ un gateway de seguridad o WAF y la salud general del objetivo.
          ## 2. Informaci√≥n General del Objetivo:
          * **Dominio/IP:** ${{ inputs.dominio }}
          * **Tecnolog√≠as Identificadas (HTTPX, WhatWeb):** Enumera las tecnolog√≠as detectadas, incluyendo versiones si est√°n disponibles.
          * **Servidor Web:** (Si se detecta)
          * **CDN/WAF Detectado (Wafw00f, Cabeceras):** Indica si se detect√≥ un WAF o CDN, y cu√°l.
          * **Puertos Abiertos (Nmap):** Lista los puertos 80 y 443 y su estado.
          ## 3. An√°lisis de Certificado SSL/TLS:
          * **Emisor:**
          * **Sujeto:**
          * **Validez (Desde/Hasta):**
          * **Nombres Alternativos (SANs):**
          * **Estado de Expiraci√≥n:** (V√°lido, pr√≥ximo a expirar, expirado, no obtenido)
          ## 4. An√°lisis de Cabeceras HTTP/S:
          * **Cabeceras de Seguridad Clave:** (X-XSS-Protection, Strict-Transport-Security, Content-Security-Policy, X-Frame-Options, X-Content-Type-Options) y su estado (presente/ausente, valor).
          * **Cabeceras de Informaci√≥n (Server, X-Powered-By):** Si se detectan, con sus valores.
          * **Cabeceras de Proxy/CDN (X-Forwarded-For, Via, CF-Ray, etc.):** Indica si se detectan y si sugieren un paso por gateway.
          ## 5. Vulnerabilidades Potenciales y Riesgos (Basado en CVEs y Tecnolog√≠as):
          * Basado en las tecnolog√≠as identificadas, lista posibles vectores de ataque o CVEs conocidas que podr√≠an ser explotadas. S√© espec√≠fico (ej: 'La versi√≥n X de Nginx es vulnerable a Y'). Considera si el WAF/Gateway es vulnerable o si est√° mal configurado.
          * Analiza si la ausencia de cabeceras de seguridad clave representa un riesgo.
          ## 6. Recomendaciones y Pr√≥ximos Pasos:
          Sugiere los pr√≥ximos 3 a 5 pasos para profundizar el an√°lisis de seguridad y mejorar la postura de seguridad del objetivo.

          Aqu√≠ est√°n los logs brutos completos de todas las herramientas. Anal√≠zalos cuidadosamente para extraer toda la informaci√≥n relevante y generar el informe seg√∫n el formato solicitado.
          "
          # --- FIN DEL PROMPT ---

          (
            echo '{ "contents": [ { "parts": [ { "text": "'
            echo "$PROMPT_TEXT" | sed 's/\\/\\\\/g; s/"/\\"/g'
            echo ""
            cat gateinspector_raw_logs.txt | sed 's/\\/\\\\/g; s/"/\\"/g; s/\x1b\[[0-9;]*m//g'
            echo '" } ] } ] }'
          ) | curl -s -X POST -H "Content-Type: application/json" \
            -d @- \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$GEMINI_API_KEY" > gemini_api_response.json || { echo "‚ùå Error: Fall√≥ la llamada a la API de Gemini."; echo "gemini_report_status=failed" >> $GITHUB_OUTPUT; exit 1; }

          RESPONSE=$(cat gemini_api_response.json)

          if echo "$RESPONSE" | jq -e 'has("error")' > /dev/null; then
            echo "‚ùå La API de Gemini retorn√≥ un error:"
            echo "$RESPONSE" | jq .
            echo "gemini_report_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if ! echo "$RESPONSE" | jq -e '.candidates[0].content.parts[0].text' > /dev/null; then
            echo "‚ùå La API de Gemini no retorn√≥ un an√°lisis v√°lido (puede haber sido bloqueado por seguridad o respuesta inesperada)."
            echo "Respuesta recibida:"
            echo "$RESPONSE" | jq .
            echo "gemini_report_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "--- INFORME GENERADO POR INSPECCION GATEWAY (VIA GEMINI AI) ---"
          echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text' > gemini_report.md
          cat gemini_report.md
          echo "---------------------------------------------------------"
          rm gemini_api_response.json

      - name: ‚úÖ Conclusi√≥n Final del An√°lisis
        run: |
          echo "---"
          echo "‚ú® **CONCLUSI√ìN FINAL DEL AN√ÅLISIS DE INSPECCI√ìN GATEWAY** ‚ú®"
          echo "---"

          if [[ "${{ inputs.gemini }}" == "true" && "${{ steps.generate_gemini_report.outputs.gemini_report_status }}" == "success" && -s "gemini_report.md" ]]; then
            echo "‚úÖ **¬°An√°lisis Completo y Potenciado por Gemini AI!**"
            echo "El informe detallado generado por la inteligencia artificial de Gemini proporciona una visi√≥n profunda y recomendaciones espec√≠ficas."
            echo "Por favor, revise el informe a continuaci√≥n o descargue 'gemini_report.md' de los artefactos del workflow."
            echo ""
            echo "--- INFORME DETALLADO DE GEMINI ---"
            cat gemini_report.md || echo "Error al mostrar el informe de Gemini."
            echo "--- FIN DEL INFORME DETALLADO ---"
          else
            echo "‚û°Ô∏è **An√°lisis Basado en Herramientas Est√°ndar.**"
            echo "El informe de Gemini no fue solicitado o no pudo ser generado. La siguiente es una tabla resumen de los hallazgos."
            echo "Para un an√°lisis m√°s profundo, considere activar la opci√≥n 'Gemini' en la pr√≥xima ejecuci√≥n."
            echo ""
            echo "üìã **Resumen de Hallazgos (Checklist Est√°ndar):**"
            echo "Dominio: **${{ inputs.dominio }}**"
            echo "---"
            
            # Formato: "Emoji Descripci√≥n del punto"
            # Usamos printf para un control de espaciado m√°s preciso.

            # 1. ¬øEl objetivo es un Gateway de Seguridad (WAF, API Gateway, Ingress, Firewall, Load Balancer)?
            if [[ "${{ steps.consolidated_data.outputs.gateway_detected }}" == "true" ]]; then
              printf "%s %s\n" "‚úÖ" "El objetivo es un Gateway de Seguridad (WAF, Ingress, CDN, etc.)"
            else
              printf "%s %s\n" "‚ùå" "El objetivo NO es un Gateway de Seguridad aparente"
            fi

            # 2. ¬øEl tr√°fico pasa por un Gateway (X-Forwarded-For, Via, etc.)?
            if cat headers_output.txt 2>/dev/null | grep -i -E 'x-forwarded|via|x-amz|x-cdn|x-gw|x-proxy'; then
              printf "%s %s\n" "‚úÖ" "El tr√°fico pasa por un Gateway/Proxy"
            else
              printf "%s %s\n" "‚ùå" "El tr√°fico NO pasa por un Gateway/Proxy aparente"
            fi

            # 3. ¬øTecnolog√≠a detectada?
            if [[ "${{ steps.consolidated_data.outputs.tecnologias }}" == "No se detectaron tecnolog√≠as espec√≠ficas con WhatWeb." ]]; then
              printf "%s %s\n" "‚ùå" "Ninguna tecnolog√≠a espec√≠fica detectada (WhatWeb limitado)"
            else
              printf "%s %s\n" "‚úÖ" "Tecnolog√≠a detectada"
            fi
            
            # 4. ¬øCertificado SSL/TLS v√°lido y vigente?
            if [[ "${{ steps.cert_summary.outputs.cert_expiration_status }}" == "V√°lido" ]]; then
              printf "%s %s\n" "‚úÖ" "Certificado SSL/TLS v√°lido y vigente"
            elif [[ "${{ steps.cert_summary.outputs.cert_expiration_status }}" == "Pr√≥ximo a expirar"* ]]; then
              printf "%s %s\n" "‚ö†Ô∏è" "Certificado SSL/TLS pr√≥ximo a expirar"
            elif [[ "${{ steps.cert_summary.outputs.cert_expiration_status }}" == "Expirado" ]]; then
              printf "%s %s\n" "‚ùå" "Certificado SSL/TLS expirado"
            else
              printf "%s %s\n" "‚ùì" "Estado del Certificado SSL/TLS desconocido/error"
            fi

            # 5. ¬øCVEs encontrados para tecnolog√≠as detectadas?
            if [ -s "cve_resultados.txt" ] && grep -q "CVE-" cve_resultados.txt; then
              printf "%s %s\n" "‚ö†Ô∏è" "CVEs encontrados para tecnolog√≠as detectadas (revisar)"
            else
              printf "%s %s\n" "‚úÖ" "Ning√∫n CVE relevante encontrado"
            fi
            echo "---"
            echo "üí° **Consideraciones de Seguridad (An√°lisis Est√°ndar):**"
            echo "La presencia de un Gateway de Seguridad y el paso del tr√°fico a trav√©s de √©l son indicadores clave de una postura de seguridad perimetral. La ausencia de estos elementos o la detecci√≥n de CVEs requiere una investigaci√≥n y mitigaci√≥n inmediatas. Un certificado expirado o pr√≥ximo a expirar tambi√©n es un riesgo cr√≠tico."
            echo "---"
          fi
          echo "--- FIN DEL AN√ÅLISIS ---"

      - name: ‚¨ÜÔ∏è Subir Artefactos de An√°lisis
        uses: actions/upload-artifact@v4
        with:
          name: inspeccion-gateway-results-${{ github.run_id }}
          path: |
            httpx_output.json
            whatweb_output.txt
            wafw00f_output.txt
            nmap_output.txt
            headers_output.txt
            cert_output.txt
            cve_resultados.txt
            gateinspector_raw_logs.txt
            gemini_report.md
          if-no-files-found: ignore
